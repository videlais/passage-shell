<html>
<body>
	<script>

		// Load the electron module with the ipcRenderer object
		const { ipcRenderer } = require('electron');

		var story = {
			name: "",
			creator: "Ink",
			author: ""
		}

		// These will be refreshed each loop
		var iframe = null;
		var iframeDocument = null;
		var storydata = null;
		var linksArray = [];

	    // Wait for Twine to load the <tw-storydata> element
	    function waitForInk() {

	    	// Get the iframe
			iframe = document.getElementById("webframe");
			// Get its document object
			iframeDocument = iframe.contentWindow.document;
			
			// If we don't find the ".written-in-ink" class,
			//  stop everything. This is not an Ink web file!
			var inkTest = iframeDocument.querySelector(".written-in-ink");

			if(inkTest == null) {
				ipcRenderer.send('async-main-error', "This is not an Ink file!");
				return;
			}

			// Check for the #story element
			storydata = iframeDocument.querySelector("#story");

	    	// If it doesn't exist, loop again
	    	if(storydata == null) {

				// Wait for default 4ms before trying again
	    		window.setTimeout(waitForInk);

	    	} else {
	    		// Everything is now ready!*/
	    		frameReady();

	    	}

	    }

		function frameReady() {

			// Get the iframe (again)
			iframe = document.getElementById("webframe");
			// Get its document object (again)
			iframeDocument = iframe.contentWindow.document;

			// Pull the name of the story from its title
			story.name = iframeDocument.querySelector("title").innerText;

			// Put the author from the element with the "byline" class
			story.author = iframeDocument.querySelector(".byline").innerText

			// Send the status
			ipcRenderer.send('async-main-status', story);

			// Send that undoing is not possible
			ipcRenderer.send('async-main-undo', false);

			storydata = iframeDocument.querySelector("#story");

			function refreshLinks() {

				linksArray = [];

				// Get the iframe (again)
				iframe = document.getElementById("webframe");
				// Get its document object (again)
				iframeDocument = iframe.contentWindow.document;
				// Get the story again
				storydata = iframeDocument.querySelector("#story");

				// Get all of the <a>
				var aLinksResults = storydata.querySelectorAll("a");

				// Move through the <a> elements
				for(var k = 0;
					k < aLinksResults.length; 
					k++) {

					linksArray.push({
						"element": aLinksResults[k],
						"text": aLinksResults[k].innerText,
						"tagName": aLinksResults[k].tagName
					});
				}

				// Send links content
				ipcRenderer.send('async-main-links', linksArray);

			}

			function refresh() {

				// Set a default value
				var passage = null;

				// Get the iframe (again)
				iframe = document.getElementById("webframe");
				// Get its document object (again)
				iframeDocument = iframe.contentWindow.document;
				// Get the story again
				storydata = iframeDocument.querySelector("#story");

				// Ink keeps the header inside of the story, so
				//  we parse the paragraphs *inside* the story.
				var ps = storydata.querySelectorAll("p");
				// Create a temporary element
				var passage = document.createElement("div");

				for(var i = 0; i < ps.length; i++) {
					// Add back each element
					passage.appendChild(ps[i]);
				}

				// Add them back
				storydata.appendChild(passage);

				// Send text content
				ipcRenderer.send('async-main-text', passage.innerText);
				// Send HTML content
				ipcRenderer.send('async-main-html', passage.innerHTML);

				// Refresh the links array
				refreshLinks();

			}

			// Send the first update
			refresh();

			ipcRenderer.on('async-remote-click', function(event, arg) {

				// Do a sanity check
				// 	arg should be greater than or equal to 0
				// 	arg should be less than number of results
				//	results should be more than 0
				if(arg >= 0 && 
				   arg < linksArray.length && 
				   linksArray.length > 0) {

					var event = new MouseEvent('click', {
						view: window,
						bubbles: true,
						cancelable: true
					});

					try {
						// Click the link or link-like element
						linksArray[arg].element.dispatchEvent(event);

					} catch (event) {

						ipcRenderer.send('async-main-error', "Could not click link or link-like element!");

					}

				}

				// Always refresh after a click event
				refresh();

			});

			// Listen for an 'undo' event from main process
			ipcRenderer.on('async-remote-undo', function(event, arg) {

				// There is no 'undo' element
				ipcRenderer.send('async-main-error', "Undo not currently supported.");

			});

	}

	</script>
	<iframe id="webframe" src="index-test/index.html" style="position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden; z-index:999999;" onload="waitForInk();">
	</iframe>
</body>
</html>